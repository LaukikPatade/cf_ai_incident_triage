// R2-based incident report export service

import { Env, IncidentState, DiagnosisResponse } from "../types";

export async function exportIncidentReport(
  env: Env,
  incident: IncidentState,
  diagnosis: DiagnosisResponse
): Promise<string> {
  const report = generateReportJSON(incident, diagnosis);
  const key = `incidents/${incident.incidentId}/${Date.now()}.json`;

  try {
    await env.INCIDENT_REPORTS.put(key, JSON.stringify(report, null, 2), {
      httpMetadata: {
        contentType: "application/json",
      },
      customMetadata: {
        incidentId: incident.incidentId,
        severity: diagnosis.severity,
        service: incident.signals.service || "unknown",
        createdAt: incident.createdAt.toString(),
      },
    });

    console.log(`Exported report to R2: ${key}`);
    return key;
  } catch (error) {
    console.error("Error exporting report:", error);
    throw error;
  }
}

export async function generateReportMarkdown(
  incident: IncidentState,
  diagnosis: DiagnosisResponse
): Promise<string> {
  const duration = ((Date.now() - incident.createdAt) / 1000 / 60).toFixed(1);

  return `# Incident Report: ${incident.incidentId}

## Overview
- **Incident ID**: ${incident.incidentId}
- **Service**: ${incident.signals.service || "Unknown"}
- **Severity**: ${diagnosis.severity}
- **Duration**: ${duration} minutes
- **Status**: Completed

## Symptoms
- **Primary Symptom**: ${incident.signals.symptom || "Unknown"}
- **Scope**: ${incident.signals.scope || "Unknown"}
- **Error**: ${incident.signals.primaryError || "None reported"}

## Timeline
- **Started**: ${new Date(incident.createdAt).toISOString()}
- **Completed**: ${new Date().toISOString()}
- **Messages Exchanged**: ${incident.conversation.length}

## Diagnosis

### Root Cause Hypotheses
${diagnosis.hypotheses.map((h, i) => `${i + 1}. **[${h.confidence}]** ${h.description}\n   - ${h.reasoning}`).join("\n\n")}

## Recommended Actions

### Immediate Actions
${diagnosis.nextSteps.immediate.map((step, i) => `${i + 1}. ${step}`).join("\n")}

### Deeper Investigation
${diagnosis.nextSteps.deeper.map((step, i) => `${i + 1}. ${step}`).join("\n")}

## Monitoring

Key metrics to watch:
${diagnosis.whatToMonitor.map(metric => `- ${metric}`).join("\n")}

## Full Conversation

${incident.conversation.map(msg => `**${msg.role.toUpperCase()}** (${new Date(msg.ts).toLocaleString()}):\n${msg.content}`).join("\n\n---\n\n")}

---
*Report generated by AI Incident Triage Assistant*
`;
}

function generateReportJSON(
  incident: IncidentState,
  diagnosis: DiagnosisResponse
): any {
  return {
    metadata: {
      incidentId: incident.incidentId,
      createdAt: new Date(incident.createdAt).toISOString(),
      completedAt: new Date().toISOString(),
      duration: Date.now() - incident.createdAt,
      messageCount: incident.conversation.length,
    },
    signals: incident.signals,
    diagnosis: {
      severity: diagnosis.severity,
      hypotheses: diagnosis.hypotheses,
      recommendations: diagnosis.nextSteps,
      monitoring: diagnosis.whatToMonitor,
    },
    conversation: incident.conversation.map(msg => ({
      role: msg.role,
      content: msg.content,
      timestamp: new Date(msg.ts).toISOString(),
    })),
  };
}

export async function getReportUrl(
  env: Env,
  key: string
): Promise<string> {
  // In production, generate a presigned URL
  // For now, return the key
  return `r2://${key}`;
}
